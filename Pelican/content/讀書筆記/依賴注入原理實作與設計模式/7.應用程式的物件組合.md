---
title: 7.應用程式的物件組合
date: 2022-04-13 13:58
modified: 2022-04-13 13:58
tags: 標籤
category: 後端程式
slug:
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]

## 定義

>所謂的『物件組合』指的是將相關聯元件之間的關係建立起來，這項作業通常是在組合根區塊中處理的。

本章的物件組合，重點在說明 選用的應用程式框架，因為採用的框架不同，問題也不同。每種框架對應的章節內容都會先以該框架如何引入DI架構開頭，再進行討論。


### 指令列介面應用程式的物件組合

首先指令：`d:\>dotnet commerce\UpdateCurency.dll EUR "0.88"`
.

範例：Commerce.UpdateCurrency

```c#
public static void Main(string[] args)
        {
            string connectionString =
                LoadConnectionString();

            CurrencyParser parser =
                CreateCurrencyParser(connectionString);

            ICommand command = parser.Parse(args);
            command.Execute();
        }
```

其中 `LoadConnectionString` `CreateCurrencyParser`  這兩個包起來的方法如下：

```c#
private static string LoadConnectionString()
        {
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: false)
                .Build();

            return configuration.GetConnectionString(
                "CommerceConnectionString");
        }
```

```c#
private static CurrencyParser CreateCurrencyParser(string connectionString)
        {
            var provider =
                new SqlExchangeRateProvider(
                    new CommerceContext(connectionString));

            return new CurrencyParser(provider);
        }
```

重點在於 CreateCurrencyParser 這個Function裡面就是這個應用程式的物件組合關聯

再詳細看看 CurrencyParser 這個實作功能的內容程式

```c#
    public class CurrencyParser
    {
        private const string HelpMessage = "Usage: UpdateCurrency <DKK | EUR | GBP> <rate>.";

        private readonly IExchangeRateProvider provider;

        public CurrencyParser(IExchangeRateProvider provider)
        {
            if (provider == null) throw new ArgumentNullException(nameof(provider));

            this.provider = provider;
        }

        public ICommand Parse(string[] args)
        {
            decimal rate;

            if (args == null || args.Length != 2 || !decimal.TryParse(args[1], out rate))
            {
                return new HelpCommand(HelpMessage);
            }

            var currencyCode = args[0];

            return new UpdateCurrencyCommand(this.provider, new Currency(currencyCode), rate);
        }
    }
```

---

![[UpdateCurrency物件組合架構.jpg]]


### ASP.NET Core MVC 框架應用程式的物件組合

#### 自定一個Controller啟動器
主要的是要找到一個介入的擴充切入點，IControllerActivator介面，如果想要以建構子注入模式，將依賴對象注入到特定的Controller類別中，就需要一個實作 IControllerActivator 介面的自訂啟動器。

>我認為為什麼要自定一個Controller啟動器，是因為要把物件組合的相關邏輯都集中起來放在應用程式的啟動點(Startup類別)，後來看到說明：以便將控制器與控制器的依賴需求對象關聯起來


重點：自己實作的Controller啟動器 `CommerceControllerActivator`
```c#
// Add custom Pure DI Controller Activator
var appSettings = this.Configuration.GetSection("AppSettings");

var controllerActivator = new CommerceControllerActivator(
    configuration: new CommerceConfiguration(          
      connectionString:this.Configuration.GetConnectionString("CommerceConnectionString")
     ,productRepositoryTypeName: appSettings.GetValue<string>("ProductRepositoryType")
    )
);

services.AddSingleton<IControllerActivator>(controllerActivator);
```


#### 在單純的DI架構建立自定的中介層

先認識一下中介層 『 [[認識AspNetCore]] 』

```c#
var logger = loggerFactory.CreateLogger("Middleware");

app.Use(async (context, next) =>
{
    var middleware = new LoggingMiddleware(logger);

    await middleware.Invoke(context, next);
});

```

上面是自定的中介層 使用 Use 方法

至於為何要介紹自定的中介層，是因為一般在網路請求的主流程之前，或之後，往往會有更多想安插的作業內容，像是Log，就會需要寫一些自定的中介層，並且最好中介層的元件最好移到建立物件組合的地方像是上面的 `CommerceControllerActivator`
