---
title: 10.設計面上的剖面導向程式設計
date: 2022-05-25 09:25
modified: 2022-05-25 09:25
tags: 標籤
category: 後端程式
slug: 自定義URL標籤
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]
## 剖面導向程式設計

定義：所謂『剖面導向程式設計』主要是為了解決在實作橫切關切點機制，以及其他設計模式時，會出現的程式碼重複編寫問題。為此，在AOP中會先在單一定點實作這份設計模式後，再以不需要修改其他既有程式碼的方式，將這份模式套用到code base中其他需要的地方，或是乾脆集中於此單點處理。

#### 常見的AOP實作方法的說明與優缺點：

### SOLID
根據需要，將剖面透過以抽象介面為中心的裝飾元件，套用在一群類別上

##### 優點：
+ 不需要工具輔助
+ 易於實作
+ 可讓心力專注於設計層面
+ 系統更具可維護性

##### 缺點：不一定能試用於傳統架構系統


### 動態攔截(CH11)
根據應用程式內部的抽象介面，於執行階段自動產生裝飾元件。這類裝飾元件會透過工具所提供的剖面切面注入進去，又稱之為『攔截器』

##### 優點：
+ 假設應用程式架構已是以介面為中心的前提下，只要稍作修改便能輕易套用在既有或傳統架構的應用程式上
+ 不需要擔心已編譯的應用程式會動態化的攔截函式庫產生緊耦合關係
+ 免費工具中也有不錯的選擇

##### 缺點：
+ 對剖面的實作會與使用的AOP工具無法分割
+ 無法獲得編譯期階段的各項好處
+ 容易造成不確定的行為與錯誤發生


### 後編譯織入(CH11)
在後期編譯階段流程中將剖面加入應用程式中。這通常是以通用中繼程式語言（Intermediate Language）連結的形式實現，透過一個外部工具讀取已編譯過的檔案，在其中修改並加上剖面的實作，把原先的內容替換為修改過的內容。

##### 優點：就算應用程式並非以介面為中心的架構，也只需要非常少量的修改就能輕易套用在既有或傳統架構的應用程式上。

##### 缺點：
+ 如果把不穩定依賴對象注入到剖面中，將有可能造成時序耦合或是測試耦合的問題
+ 由於是在後編譯期階段將剖面寫入進去，因此不可能再呼叫到沒有被套用到剖面的程式碼版本。這會提高測試的複雜度，並且降低彈性。
+ 而且後編譯期階段的連結其實與DI架構背道而馳。



### 透過SOLID五原則達成AOP

SOLID的說明另外獨立[[SOLID五原則]] 連結，先分析違反那些原則，在透過SOLID五原則改善設計

#### 第一步：把讀取與寫入的動作分開

以範例`IProductService`介面包含的方法有更新，讀取，新增等等，先分割成`IProductQueryServices` 跟 `IProductCommandServices`。
![[把讀取與寫入的動作分開.jpg]]
這種分離的好處在於介面比起之前能夠更加精實，減低了在依賴對象中有著冗餘方法的機率。

NOET：『命令與查詢分離』原則

>命令與查詢分離原則（Command-Query Separtion），CQS後來成爲在物件導向程式設計中一項影響深遠的原則，並主張任何方法都應該符合以下兩種之一：
>1.方法會回傳結果，但不改變系統的任何可見狀態
>2.方法不會產生結果，但會改變系統的狀態


#### 第二步：遵循ISP與SRP原則分開介面與實作

![[遵循ISP與SRP原則分開介面與實作.jpg]]
原本有七個方法成員的 `IProductCommandServices`　介面被重新分割爲一個方法成員的七個介面。而每個介面都有一個對應的實體類別。
好處
1.可以保證不會有使用方依賴於自己不需要的方法
2.確保每種使用情境都對應一個類別，有單一職責原則
3.新增功能就等於要新編寫一組介面與實體類別

#### 第三步：利用參數物件修正OCP問題

把所有參數都物件化，所謂的『參數物件』，就是把一整組參數全部放在一個實體物件當中。然後重新定義一個統整所有命令類別的介面『`ICommandService`』。
![[利用參數物件修正OCP問題.jpg]]

#### 第四步：利用泛型修正抽象介面的LSP問題

範例流程修改分四步（若是用裝飾者模式可忽略）：
1.改抽象介面爲泛型
2.改實做業務層Service爲泛型
3.改Controller的依賴注入的參數爲泛型
4.改裝飾者模式物件爲泛型
5.看組合根結構

1.改抽象介面爲泛型
```c#
public interface ICommandService<TCommand>
{
	void Execute(TCommand command);
}
```

2.改實做業務層Service爲泛型
```c#
public class AdjustInventoryService : ICommandService<AdjustInventory>
{
	private readonly IInventoryRepository repository;
	private readonly IEventHandler<InventoryAdjusted> handler;

	public AdjustInventoryService(
		IInventoryRepository repository, IEventHandler<InventoryAdjusted> handler)
	{
		if (repository == null) throw new ArgumentNullException(nameof(repository));
		if (handler == null) throw new ArgumentNullException(nameof(handler));

		this.repository = repository;
		this.handler = handler;
	}

	public void Execute(AdjustInventory command)
	{
		int quantityAdjustment = command.Quantity * (command.Decrease ? -1 : 1);

		var productInventory = this.repository.GetByIdOrNull(command.ProductId)
			?? new ProductInventory { Id = command.ProductId };

		productInventory.Quantity += quantityAdjustment;

		if (productInventory.Quantity < 0) 
			throw new InvalidOperationException("Can't decrease below 0.");

		this.repository.Save(productInventory);

		this.handler.Handle(
			new InventoryAdjusted(command.ProductId, quantityAdjustment)
		);
	}
}
```

3.改Controller的依賴注入的參數爲泛型
```c#
public class InventoryController : Controller
{
	private readonly IProductRepository repository;
	//這裏內部參數在接的時候改成泛型
	private readonly ICommandService<AdjustInventory> inventoryAdjuster;

	//這個Controller在注入實做業務邏輯Service(就是AdjustInventoryService)，這裡看不出
	public InventoryController(
		IProductRepository repository, 
		ICommandService<AdjustInventory> inventoryAdjuster)
	{
		if (repository == null) 
			throw new ArgumentNullException(nameof(repository));
		if (inventoryAdjuster == null) 
			throw new ArgumentNullException(nameof(inventoryAdjuster));

		this.repository = repository;
		this.inventoryAdjuster = inventoryAdjuster;
	}

	[Route("inventory/adjustinventory")]
	public ActionResult AdjustInventory(AdjustInventoryViewModel viewModel)
	{
		if (!this.ModelState.IsValid)
		{
			return this.View(nameof(Index), this.Populate(viewModel));
		}

		AdjustInventory command = viewModel.Command;
		//直接用抽象介面的方法Execute（實做是AdjustInventoryService）
		this.inventoryAdjuster.Execute(command);

		this.TempData["SuccessMessage"] = "Inventory successfully adjusted.";

		return this.RedirectToAction(nameof(HomeController.Index), "Home");
	}
}
```

4.改裝飾者模式物件爲泛型

```c#
//這個裝飾者模式主要在TransactionScope的運用，參考P.412 頁
public class TransactionCommandServiceDecorator<TCommand>:ICommandService<TCommand>
{
	private readonly ICommandService<TCommand> decorate;

	public TransactionCommandServiceDecorator(ICommandService<TCommand> decorate)
	{
		this.decorate = decorate;
	}

	public void Execute(TCommand command)
	{
		//用TransactionScope就可以把裏面所用的生命週期限制在同一交易作業階段
		using(var scope = new TransactionScope())
		{
			this.decorate.Execute(command)
			scope.Complete();
		}
	}
}
```


5.看組合根結構

```c#
new InventoryController(
	new TransactionCommandServiceDecorator<AdjustInventory>(
		new AdjustInventoryService(repository)
	)
);
```


後續書中實做了兩個AOP的機制：『實做稽核紀錄剖面 』『實做資安管控剖面』，這個說明移到

『 [[裝飾模式]] 』查看