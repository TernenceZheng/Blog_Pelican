---
title: 目錄
date: 2022-04-12 20:20
modified: 2022-04-12 20:20
tags: 標籤
category: 後端程式
slug: 自定義URL標籤
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]


## PART I 朝著依賴注入邁進  
  
**Chapter 1 [[1.依賴注入的基礎：定義、理由與實作方法]]**  
1.1 編寫易於維護的程式碼  
1.1.1 對依賴注入的常見誤解  
1.1.2 為何需要依賴注入  
1.2 初步的範例：Hello DI!  
1.2.1 Hello DI!的程式碼  
1.2.2 依賴注入能帶來的好處  
1.3 適合與不適合注入的對象  
1.3.1 穩定依賴性  
1.3.2 不穩定依賴性  
1.4 依賴注入在軟體中牽涉的範疇  
1.4.1 物件的組合  
1.4.2 物件的生命週期  
1.4.3 物件的攔截  
1.4.4 三種不同面向上的 DI  
1.5 小結  
重點回顧  
  
**Chapter 2 [[2.緊耦合架構]]**  
2.1 先寫一份緊耦合架構出來  
2.1.1 以 Mary Rowan 為例  
2.1.2 建立資料層  
2.1.3 建立業務層  
2.1.4 建立展示層  
2.2 評估緊耦合架構應用程式  
2.2.1 依賴關係圖  
2.2.2 對可組合性的評估  
2.3 缺乏可組合性的問題根源  
2.3.1 對依賴關係圖的剖析  
2.3.2 對資料層的剖析  
2.3.3 其他需要關注的問題  
2.4 小結  
重點回顧  
  
**Chapter 3 [[3.鬆耦合架構]]**  
3.1 重新打造電商網站應用程式  
3.1.1 打造更具可維護性的展示層  
3.1.2 打造獨立於依賴的業務層  
3.1.3 打造新的資料層  
3.1.4 配合 ASP.NET 核心所實作的 IUserContext  
3.1.5 在「組合根」組裝你的應用程式  
3.2 分析鬆耦合架構應用程式  
3.2.1 元件之間的互動關係  
3.2.2 分析新的依賴關係圖  
3.3 小結  
重點回顧  
  
## PART II 分門別類  
  
**Chapter 4 [[4.DI 設計模式]]**  
4.1 組合根  
4.1.1 組合根的運作方式  
4.1.2 在組合根上運用 DI 容器  
4.1.3 範例：純 DI 架構的組合根  
4.1.4 依賴數量的爆增表象  
4.2 建構子注入  
4.2.1 建構子注入的運作方式  
4.2.2 建構子注入的使用時機  
4.2.3 建構子注入的使用實例  
4.2.4 範例：在主打商品清單加上貨幣轉換功能  
4.2.5 結論是...  
4.3 方法注入  
4.3.1 方法注入的運作方式  
4.3.2 方法注入的使用時機  
4.3.3 方法注入的使用實例  
4.3.4 範例：在 Product 資料實體加入貨幣轉換  
4.4 屬性注入  
4.4.1 屬性注入的運作方式  
4.4.2 屬性注入的使用時機  
4.4.3 屬性注入的使用實例  
4.4.4 範例：利用屬性注入來擴展可重複利用的函式庫  
4.5 如何選擇設計模式  
4.6 小結  
重點回顧  
  
**Chapter 5 [[5.DI 反模式]]**  
5.1 控制狂  
5.1.1 範例：建立依賴關係時的控制狂  
5.1.2 範例：工廠模式下的控制狂  
5.1.3 範例：對建構子多載時的控制狂  
5.1.4 對控制狂反模式的反思  
5.2 服務定位  
5.2.1 範例：ProductService 中的服務定位  
5.2.2 對服務定位反模式的反思  
5.3 環境物件  
5.3.1 範例：查詢時間用的環境物件  
5.3.2 範例：紀錄時用的環境物件  
5.3.3 對環境物件反模式的反思  
5.4 限制性建構  
5.4.1 範例：ProductRepository 的晚期繫結  
5.4.2 對限制性建構反模式的反思  
5.5 小結  
重點回顧  
  
**Chapter 6 [[6.程式異樣]]**
6.1 建構子過度注入的程式異樣  
6.1.1 辨識建構子過度注入  
6.1.2 將建構子過度注入重構為前台模式  
6.1.3 將建構子過度注入重構為業務事件  
6.2 抽象工廠的濫用  
6.2.1 為了生命週期問題而濫用了抽象工廠  
6.2.2 為了在執行期決定依賴對象而濫用抽象工廠  
6.3 循環依賴  
6.3.1 範例：違反 SRP 原則造成的循環依賴  
6.3.2 分析 Mary 的依賴循環  
6.3.3 解決違反 SRP 問題以重構循環依賴  
6.3.4 打破依賴循環的策略  
6.3.5 最終手段：以屬性注入來打破依賴的循環  
6.4 小結  
重點回顧  
  
## PART III 單純 DI 架構
  
**Chapter 7 [[7.應用程式的物件組合]]**  
7.1 指令列介面應用程式的物件組合  
7.1.1 範例：以 UpdateCurrency 程式來更新貨幣匯率  
7.1.2 建立 UpdateCurrency 程式的組合根  
7.1.3 在 CreateCurrencyParser 中組合物件關聯  
7.1.4 剖析 UpdateCurrency 的架構層  
7.2 通用 Windows 平台應用程式的物件組合  
7.2.1 UWP 應用程式的物件組合  
7.2.2 範例：建立一個商品管理 app  
7.2.3 在UWP 應用程式中實作組合根  
7.3 ASP.NET 核心 MVC 框架應用程式的物件組合  
7.3.1 自訂一個 Controller 啟動器  
7.3.2 在單純DI 架構建立自訂的中介層  
7.4 小結  
重點回顧  
  
**Chapter 8 [[8.物件生命週期]]**  
8.1 管理依賴對象的生命週期  
8.1.1 生命週期的管理  
8.1.2 在單純 DI 架構下管理生命週期  
8.2 處理依賴的廢棄問題  
8.2.1 處理可廢棄依賴對象  
8.2.2 管理可廢棄的依賴對象  
8.3 生命週期型態彙整  
8.3.1 單例型態  
8.3.2 一次性型態  
8.3.3 作用域型態  
8.4 不良生命週期型態  
8.4.1 被綁架的依賴  
8.4.2 抽象漏洞造成的生命週期型態資訊洩漏  
8.4.3 與執行緒生命週期綁定的物件會造成並行上的問題  
8.5 小結  
重點回顧  
  
**Chapter 9 [[9.介入攔截]]**  
9.1 關於攔截  
9.1.1 裝飾者設計模式  
9.1.2 範例：以裝飾者模式實作稽核機制  
9.2 實作橫切關切點  
9.2.1 以攔截實作斷路器設計模式  
9.2.2 在回報例外錯誤時利用裝飾者模式  
9.2.3 在保護機敏功能避免非法存取時利用裝飾者模式  
9.3 小結  
重點回顧  
  
**Chapter 10 [[10.設計面上的剖面導向程式設計]]**  
10.1 何謂剖面導向程式設計  
10.2 關於 SOLID 五原則  
10.2.1 單一職責原則（SRP）  
10.2.2 開放封閉原則（OCP）  
10.2.3 里氏替換原則（LSP）  
10.2.4 介面切離原則（ISP）  
10.2.5 依賴反轉原則（DIP）  
10.2.6 攔截與 SOLID 五原則之間的關係  
10.3 透過 SOLID 五原則達成AOP  
10.3.1 範例：以 IProductService 實作商品相關功能項目  
10.3.2 以 SOLID 五原則的觀點分析 IProductService  
10.3.3 遵循 SOLID 五原則改善設計  
10.3.4 添加更多橫切關切點機制  
10.3.5 本章結語  
10.4 小結  
重點回顧  
  
**Chapter 11 [[11.以工具實作的剖面導向程式設計]]**  
11.1 動態攔截  
11.1.1 範例：以 Castle Dynamic Proxy 實作攔截  
11.1.2 對動態攔截的分析  
11.2 後編譯織入  
11.2.1 範例：利用後編譯織入實作交易階段剖面  
11.2.2 對後編譯織入的分析  
11.3 小結  
重點回顧  
  
## **PART IV DI 容器技術**  
  
**Chapter 12 [[12.DI 容器]]**  
12.1 關於 DI 容器技術  
12.1.1 關於容器技術的解析 API  
12.1.2 自動裝配  
12.1.3 範例：實作自動裝配功能的簡易 DI 容器  
12.2 設定 DI 容器  
12.2.1 以設定檔來設定容器  
12.2.2 以程式化設定來設定容器  
12.2.3 以自動註冊功能達到規範先於設定的容器設定方式  
12.2.4 不同設定方式之間的搭配  
12.3 採用 DI 容器技術的時機  
12.3.1 引入第三方函式庫的成本與風險  
12.3.2 單純 DI 架構能有更快的回饋循環  
12.3.3 採用 DI 容器技術的確切時機  
12.4 小結  
重點回顧  
  
**Chapter 13 [[13.DI 容器介紹：Autofac]]**  
13.1 介紹 Autofac  
13.1.1 物件解析  
13.1.2 對 ContainerBuilder 的設定  
13.2 管理生命週期  
13.2.1 設定物件作用域  
13.2.2 釋放元件  
13.3 以進階 API 執行註冊  
13.3.1 設定基本型別的依賴關係  
13.3.2 指定物件產生來源的註冊方式  
13.4 多重註冊關係的處理方式  
13.4.1 多個對映選項下的抉擇方式  
13.4.2 對序列的裝配  
13.4.3 裝飾元件的裝配  
13.4.4 合成元件的裝配  
13.5 小結  
重點回顧  
  
**Chapter 14 [[14.DI 容器介紹：Simple Injector]]**  
14.1 介紹 Simple Injector  
14.1.1 物件解析  
14.1.2 對 Container 的設定  
14.2 管理生命週期  
14.2.1 設定生命週期型態  
14.2.2 釋放元件  
14.2.3 作用域的全域管理  
14.2.4 對常見生命週期議題的偵測分析  
14.3 以進階 API 執行註冊  
14.3.1 設定基本型別的依賴關係  
14.3.2 將基本型別依賴轉為參數物件  
14.3.3 指定物件產生來源的註冊方式  
14.4 多重註冊關係的處理方式  
14.4.1 多個對映選項下的抉擇方式  
14.4.2 對序列的裝配  
14.4.3 裝飾元件的裝配  
14.4.4 合成元件的裝配  
14.4.5 其實有著串流內在的序列  
14.5 小結  
重點回顧  
  
**Chapter 15[[15.DI 容器介紹：Microsoft.Extensions.DependencyInjection]]**  
15.1 介紹Microsoft.Extensions.DependencyInjection  
15.1.1 物件解析  
15.1.2 對 ServiceCollection 的設定  
15.2 管理生命週期  
15.2.1 設定生命週期型態  
15.2.2 釋放元件  
15.3 以進階 API 執行註冊  
15.3.1 設定基本型別的依賴關係  
15.3.2 將基本型別依賴轉為參數物件  
15.3.3 指定物件產生來源的註冊方式  
15.4 多重註冊關係的處理方式  
15.4.1 多個對映選項下的抉擇方式  
15.4.2 對序列的裝配  
15.4.3 裝飾元件的裝配  
15.4.4 合成元件的裝配  
15.5 小結  
重點回顧