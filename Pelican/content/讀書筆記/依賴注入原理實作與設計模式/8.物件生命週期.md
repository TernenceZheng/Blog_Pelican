---
title: 8.物件生命週期
date: 2022-04-13 14:00
modified: 2022-04-13 14:00
tags: 標籤
category: 後端程式
slug:
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]

學習重點：

+ 管理依賴對象的生命週期
+ 處理依賴對象的廢棄問題，
+ 運用單例、一次性、與作用域等不同生命週期形態
+ 如何避免或修正不良的生命週期形態

### 生命週期的管理

物件關聯中的所有物件並非都是在同一時間建立出來的。在物件離開屬於它的作用域後就會被視為垃圾回收的對象。因此反過來說，只要程式中還有某處繼續有對這份物件的參照，這份物件都會一直存在著。雖然使用方無法真正自行廢棄物件(因為這是垃圾回收機制的職責)，但卻能夠抓著那份參照不放，讓物件持續存在下去，而這正是我們會再建構子注入發生的情境，因為你把依賴對象都放入私有的private欄位中了:

```c#
    public class HomeController : Controller
    {
        private readonly IProductService productService;

        public HomeController(IProductService productService)
        {
            this.productService = productService;
        }
    }
```


如下圖：以同一份依賴對象注入到多個使用方，就會照成物件被其他參照抓著不放的可能
![[同一份依賴多個使用方.jpg]]


### 單純DI架構管理生命週期


![[commerce物件關聯圖.jpg]]

在這個範例要如何管理生命週期。

重複利用的物件（單例singleton）: `AspNetUserContextAdapter`  `RouteCalculator`
每次都要獨立建立的（一次性transient）: `ProductService`   `SqlProductRepository`

程式範例在 P.306 的 程式碼範例8.3
重點的差異在：

```c#
// Singletons
//在內部宣告參數物件存放
private readonly IUserContext userContext;
private readonly RouteCalculator calculator;

public class CommerceControllerActivator : IControllerActivator
{
	public CommerceControllerActivator(CommerceConfiguration configuration)
	{
		//要重複利用的就是在這裡 new 出來後存放在內部參數物件
		this.userContext = new AspNetUserContextAdapter();
		this.calculator = new RouteCalculator(this.CreateRouteController())	
	}

	public Controller Create(Type type)
	{
		// Create Scoped components
		var context = new CommerceContext(this.configuration.ConnectionString);

		//後面要實做廢棄方法在這裏先準備增加追蹤
		//TrackDisposable(ControllerContext context,IDisposable disposable)

		// Create Transient components
		switch (type.Name)
		{
			//要一次性的物件就在方法內部才new出物件實體，不存放在內部參數物件
			case nameof(HomeController):
				return new HomeController(
					new ProductService(
						new SqlProductRepository(context),this.userContext));
		}
	}
}
```


### 處理依賴的廢棄問題

由上面的範例可以知道，當一個物件被兩個使用方繫結，就會造成.NET的垃圾回收機制無法掌控，這類的情況就是『記憶體洩漏』，然而要如何管理可廢棄的(IDisposable)依賴對象，就要把責任落在組合器上了，就是上面的IControllerActivator


爲了釋放這些依賴對象，組合器需要一一確認先前建立與提供過的可廢棄依賴對象物件，以及使用這些物件的使用方，而且還要確保廢棄物件的順序正確。
![[物件廢棄流程.jpg]]


流程：先把需要廢棄的物件放在HttpContext.Items字典物件內=>實做廢棄方法=>在Main方法最後呼叫


#### 先把需要廢棄的物件放在HttpContext.Items字典物件內

```c#
private static void TrackDisposable(ControllerContext context,IDisposable disposable)
{
	IDictionary<object,object> items = context.HttpContext.Items;

	object list;
	if(!items.TryGetValue("Disposables",out list))
	{
		list = new List<IDisposable>();
		items["Disposables"] = list;
	}
	((List<IDisposable>)list).Add(disposable);
}
```



#### 實做：

```c#
//CommerceControllerActivator裏面的廢棄方法
public void Release(ControllerContext context, object controller) =>
            (controller as IDisposable)?.Dispose();
```

改寫：
```c#
public void Release(ControllerContext context, object controller)
{
	var disposables = (List<IDisposable>)context.HttpContext.Items["Disposables"];
	if(disposables != null)
	{
		disposables.Reverse(); //將物件循序翻轉就是建立物件的順序
		foreach(IDisposable disposable in disposables)
		{
			disposable.Dispose();
		}
	}
}
```


>Note:
上面TrackDisposable與Release的機制，在ASP.NET MVC的框架下，用`HttpContext.Response.RegisterForDispose` 這樣的方法就可以跟上面的廢棄機制一樣。另外如果是在DI容器的技術下，就可用DI容器技術去管理廢棄問題，上面這些都是因爲用純DI機制所以要自行處理廢棄管理問題。



### 生命週期型態彙整

| 名稱       | 說明                                                   |
| ---------- | ------------------------------------------------------ |
| 單例型態   | 單一份物件被重複利用                                   |
| 一次性形態 | 每次都會提供不同一份新建的物件                         |
| 作用域型態 | 在規定的作用域中，每種型別的依賴對象都只存在單一份物件 | 


參考資料：  [ASP.NET Core 3 系列 - 依賴注入 (Dependency Injection)](https://blog.johnwu.cc/article/asp-net-core-3-dependency-injection.html)

在純DI架構下的生命週期型態有上面三個型態，另外如果在ASP.NET Core框架下，有現成的使用方式可以使用就如同參考資料連結的文章。

#### 單例型態
在執行緒安全的存在下，使用單例型態的生命週期是最好的選擇。何謂執行緒安全：所有無狀態，無法被更動的型別，當然還有那些設計上符合執行緒安全定義的類別。
[C# 中的執行緒安全列表](https://www.delftstack.com/zh-tw/howto/csharp/csharp-thread-safe-list/)

#### 一次性型態
重點是物件有實做IDisposable介面，組合器就需要追蹤物件生命週期，並且要確實執行廢棄。
注意：如果是在DI容器技術框架下，一次性型態物件的使用就會有所不同。有些DI容器技術不會去主動廢棄，需要自行廢棄。


#### 作用域型態
適合用於那種有著一定程度處理獨立作業類型，長時間運作的應用程式。
這邊所說的獨立作業，是會各自平行處理，又或是以獨立的狀態進行，就像是網頁應用程式會以平行的方式處理網路請求。

用CurrencyMonitoring的範例來說明作用域型態

![[作用域型態架構圖.jpg]]


### 不良的生命週期

| 名稱             | 造成問題 | 說明                                           |
| ---------------- | -------- | ---------------------------------------------- |
| 被綁架的依賴     | 程式缺陷 | 依賴對象的存續時間超過原本的預期               |
| 抽象漏洞         | 設計問題 | 生命週期型態的規劃資訊透過抽象漏洞洩漏給使用方 |
| 綁定執行緒的型態 | 程式缺陷 | 物件的生命週期與執行緒綁定造成並行上的程式缺陷 |                                             |


#### 被綁架的依賴(Captive Dependences)

定義：
指的是有依賴對象物件，因爲物件使用方的緣故，導致物件的存續時間超過其原本所規劃的生命週期型態長度。最常見的就是把生命週期短暫的依賴對象物件，注入到一個單例型態的使用方中。

當你採用DI容器技術時，被綁架的依賴是很常鍵的一項問題。由於DI容器技術的動態性質，所有很容易忘記自己開發出來的物件關聯圖架構樣貌，所有最好是具備有 被綁架依賴問題的偵測工具。

#### 抽象漏洞造成的生命週期型態資訊洩漏

使用情境：

當有某種依賴對象的使用率不高，建立物件的成本又太高，可能會打算改爲在物件關聯都組合好之後，才建立這份物件，但是這樣做的話就會把 實做 組合根中的實做 等資訊透露給使用方知悉，於是這份依賴對象就會成爲抽象漏洞。

用來延後建立物件的方式，範例提供說明下列物件包裝方式：

##### `System.Lazy<T>`類別

##### `IEnumerable<T>抽象介面`

負面案例：

```c#
//使用方ProductService直接用Lazy<IUserContext> 來做注入
public class ProductService : IProductService
{
	private readonly IProductRepository repository;
	private readonly Lazy<IUserContext> userContext; //<==這裏用

	public ProductService(
		IProductRepository repository,
		Lazy<IUserContext> userContext) //<==注入用這樣的方式
	{
		this.repository = repository;
		this.userContext = userContext;
	}

	public IEnumerable<DiscountedProduct> GetFeaturedProducts()
	{
		return
			from product in this.repository
				.GetFeaturedProducts()
			select product.ApplyDiscountFor(this.userContext.value);
	}
}
```

```c#
public class Componet
{
	private readonly IEnumberalbe<ILogger> loggers;

	public Componet(IEnumerable<ILogger> looggers) <= 使用這樣的建構子不好
	{
		this.looggers = loggers;
	}
}
```

通常解決抽象漏洞的解決方法：建立一個包裝用的類別

`Lazy<T>` 就使用虛擬代理隱藏
`IEnumberabl<T>`用合成模式修改

修改方式：參閱 P.344   P.347，主要就是用類別去包上面兩個方式，然後在去注入依賴對象

#### 執行緒生命週期綁定的物件會造成並行上的問題

負面範例：

```c#
//重點就是這個定義爲執行緒，這個修飾子欄位可以保證物件不會跨執行緒被共用，這樣CommerceContext這個依賴注入的物件就跟執行緒綁定了
[ThreadStatic]
private static CommerceContext context;

private static CurrencyParser CreateCurrencyParser(string connectionString)
{
	if(context == null)
	{
		context = new CommerceContext(connectionString);
	}
	
	var provider =
		new SqlExchangeRateProvider(context);

	return new CurrencyParser(provider);
}
```


用書上的圖來說明並行上的問題：


![[生命週期型態被執行緒綁定.jpg]]


與其讓依賴對象與執行緒綁定，不如與請求的作用域生命週期綁定即可。