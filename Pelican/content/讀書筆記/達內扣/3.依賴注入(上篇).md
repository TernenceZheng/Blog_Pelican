---
title: 依賴注入(上篇)
date: 2022-03-29 19:37
modified: 2022-03-29 19:37
tags: 標籤
category: 後端程式
slug: 自定義URL標籤
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]


#### 控制反轉（Inverse of Control）
對於任何一項工作，不論大小，基本上都可以分解成對應的步驟，所以任何一項工作的實施都有固定的流程，而IoC的控制就是視作『***針對流程的控制***』。一般來講，設計模式是為了解決一個實際問題的方案，但是IoC沒有一個針對性的問題領域，本身也沒有提供一種可操作的解決方案，所以認為視為IoC是一種『***設計原則***』，

舉例來說，ASP.NET MVC 架構在處理請求的過程，就是一個針對流程的控制。路由解析產生參數獲得目標Controller的類型，然後自動建立Controller物件並執行，如果Action方法需要呈現View，架構就會根據預先定義好的目錄找到對應的View檔案(.cshtml檔)，並且實施動態編譯產生對應的類型。整個請求流程就是『架構Call應用』的原則。

在許多的設計模式中，也有幾個方式展現了IoC的設計原則：

[[模板方法]]
[[工廠模式]]
[[抽象工廠]]


#### 依賴注入Dependency Injection(DI) 


這裏的說明書上的寫的不是很好，另外參考了別的部落格，放在『[[依賴注入系列]]』。另外需要去好好的瞭解什麼是『[[服務定位模式]] 』

節錄部分書中重點：


ASP.NET CORE 在啓動的時候會呼叫註冊的Startup物件來完成中介軟體的註冊，而定義Startup類型的時候不需要讓他實現某個界面，所以用在註冊中介軟體的Configure方法沒有一個固定的宣告，但是可以按照以下方式將任意依賴的服務實例直接注入這個方法。

```C#
public class Startup
{
	public void Configure(IApplicationBuilder app,IFoo foo,IBar bar,IBaz baz);
}
```

類似的注入方式同樣可以應用到中介軟體類型的定義上。與用來註冊中介軟體的Startup類型一樣，ASP.NET Core 架構下，用於處理請求的InvokeAsync方法或Invoke方法同樣可以用下列方式來注入任意的依賴服務。

```c#
public class FoobarMiddlewre
{
	private readonly RequestDelegate _next;
	public FoobarMiddleware(RequestDelegate next)=> _next = next;

	public Task InvokeAsync(HttpContext httpContext,IFoo foo,IBar bar,IBaz baz);
}
```

上面這種方式的 `方法注入` 促成一種『針對約定』的程式設計方式。


