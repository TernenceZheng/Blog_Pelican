---
title: 依賴注入系列
date: 2022-04-07 20:17
modified: 2022-04-07 20:17
tags: 標籤
category: 後端程式
slug: 自定義URL標籤
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]



[菜雞與物件導向 (14): 依賴反轉原則](https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/)

#### **高階模組不應該依賴於低階模組，兩者都應該依賴抽象**。為了解除耦合，必須用介面這種抽象層進行隔離。

#### **抽象不應該依賴細節。細節應該依賴抽象**。介面應該是高階模組提出的要求，然後才去使用實作了這些要求的低階模組。這些實作應該圍繞著這些要求，而不是讓要求去配合實作，更不要讓要求中包含實作。

#### **為了解決介面實例化仍然會產生依賴的問題，就有了控制反轉**。把控制權交給第三方，藉此讓使用者能夠不用關心實例化的過程，而注重在使用並達成目標的職責上。

#### **而控制反轉的具體實現方法是依賴注入**，藉由從建構式傳遞、更改目標的屬性等方式，把低階模組交給高階模組使用者。當我們藉由依賴注入的方式實現控制反轉，就能夠讓物件的設計符合依賴反轉原則。

---


[菜雞新訓記 (6): 使用 依賴注入 (Dependency Injection) 來解除強耦合吧](https://igouist.github.io/post/2021/11/newbie-6-dependency-injection/)


## 依賴注入的種類

白話一點來說，「注入」也就是「丟進去」的意思。所以**依賴注入就是指用各種方法把低階模組丟到高階模組裡**。

主要常見的有三種作法：建構式注入、方法注入、屬性注入。也就是從建構式丟進去、從方法丟進去、從屬性丟進去。


### 建構式注入

建構式注入顧名思義就是**從建立物件時的建構式進行注入**。

由於建構式注入比較符合封裝的「管控邊界」精神、能明確地讓維護者一看就知道哪些東西會被注入，因此**絕大部分的時候都應該使用建構式注入**，只有特殊情況可以使用方法注入和屬性注入。而到了 .net Core 的時代，預設的 DI 容器更是只提供建構式注入。所以理想的情況下，建構式注入應該要是最熟悉的注入方式。

### 方法注入

**方法注入適用於「呼叫方法時需要注入不同的依賴對象」時**。例如說該方法在不同地方被呼叫的依賴對象不一樣，又或者是第一次呼叫和第二次呼叫時的依賴對象不一樣。

這時候我們就可以**在呼叫方法的時候才把依賴對象一起丟進去**，讓使用端來決定要注入什麼。


### 屬性注入

接著讓我們來看看屬性注入，顧名思義就是**從公開的屬性丟進去**，因此有時候也會被叫做設值注入。

通常我們會在 **「外部使用者要能夠隨時切換依賴對象」或是「類別已經有預設值了，但希望提供使用者可以覆寫掉預設值的彈性」時用到屬性注入**


## .Net Core 中的依賴注入

接著讓我們回到本系列的專案吧。可喜可賀的是：**在 .net Core 的時代，依賴注入已經是內建提供的功能了！**

> 補充：使用 .net Framework 的朋友也不用擔心，可以使用 Unity, AutoFac 這幾個猛猛的 IoC 容器。教學文章也是網路一抓一大把那種。
> 
> 甚至到了預設使用建構式注入的 .net Core 時代，還是不少人會為了要用動態代理之類的花式注入手段而把 Autofac 裝回來呢。


### 依賴注入的三種生命週期 Transient、Scoped、Singleton

除了 `AddScoped()` 以外，.net Core 還提供了另外兩種注入方法：`AddTransient()` 和 `AddSingleton()`，他們對應的是三種不同的生命週期：

-   **Transient（一次性）**：每次注入都建立一個新的
-   **Scoped（作用域）**：每次 Request 都建立一個新的，同個 Request 重複利用同一個
-   **Singleton（單例）**：只建立一個新的，每次都重複利用同一個