---
title: DI 設計模式
date: 2022-04-13 13:55
modified: 2022-04-13 13:55
tags: 標籤
category: 後端程式
slug: 自定義URL標籤
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]

### DI的基本設計模式：

- 組合根：告訴你應該在何處，以及如何組合出應用程式的物件關聯

- 建構子注入：讓類別可以用靜態的方式定義其依賴關係需求

- 方法注入：在使用方對依賴關係的對象需求可能會隨每次作業而有所不同時，可以用這個方式來滿足使用方的依賴關係

- 屬性注入：讓用戶端可以隨需求覆寫某些類別的內建預設行為，這些內建預設的實作是在類別本身之內

---

### 組合根

當從鬆耦合架構許許多多的類別中建立的應用程式，這個組合，建立的動作，應該盡可能安排在應用程式的流程啟動點。因此所謂的『組合根』，你可以視為一種第三方元件，用來協助這些類別，將彼此之間作為使用方與服務提供方的角色關係連結起來。

請注意，雖然在範例中，是將組合根與展示層放在同一份組件檔底下，但是組合根並不屬於該架構層，不要因此將組合根誤解為展示層的一部分。

#### DI容器技術
所謂的DI容器技術指的就是一套軟體函式庫，協助我們將許多包括『物件關聯組合』，『管理物件生命週期』等作業自動化。
*應該只讓組合根運用DI容器技術，而且也應該只在組合根中運用，至於其他部分的程式則不應該採用DI容器。*

---

#### 純DI架構的組合根

在ASP.NET Core中，程式的啟動點就定義在Startup裡面，以範例程式中來看DI的架構

```c#
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            this.Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            // Add framework services.
            services.Configure<CookiePolicyOptions>(options =>
            {
                // This lambda determines whether user consent for non-essential cookies is needed for a given request.
                options.CheckConsentNeeded = context => true;
                options.MinimumSameSitePolicy = SameSiteMode.None;
            });

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
            services.AddHttpContextAccessor();

            // Add custom Pure DI Controller Activator
            var appSettings = this.Configuration.GetSection("AppSettings");

            var controllerActivator = new CommerceControllerActivator(
                configuration: new CommerceConfiguration(
                    connectionString: this.Configuration.GetConnectionString("CommerceConnectionString"),
                    productRepositoryTypeName: appSettings.GetValue<string>("ProductRepositoryType")));

            services.AddSingleton<IControllerActivator>(controllerActivator);
        }
    }
```

重點在 

```c#
            // Add custom Pure DI Controller Activator
            var appSettings = this.Configuration.GetSection("AppSettings");

            var controllerActivator = new CommerceControllerActivator(
                configuration: new CommerceConfiguration(
                    connectionString: this.Configuration.GetConnectionString("CommerceConnectionString"),
                    productRepositoryTypeName: appSettings.GetValue<string>("ProductRepositoryType")));

            services.AddSingleton<IControllerActivator>(controllerActivator);
```

這裡我們自己客製了自己的CommerceControllerActivator的實作，透過由ASP.NET Core的IControllerActivator介面來注入，讓我們看一下這個介面的方法


![[Pasted image 20220429105033.png]]

當MVC框架呼叫Create方法時，可以根據要求的Controller類型，建立出對應的物件關聯，這裡這麼做的原因是因為，給予呼叫方可進行設定的管道會比較有彈性。因此讀取設定檔的動作，應該要從物件組合相關的方法分開來進行，分開的好處是讓『組合物件的相關方法』與『設定系統』之間沒有直接依賴關係

---
### 建構子注入

必須在Public 修飾子的建構子中以建構子參數的形式，定義這份依賴需求，要求外部提供物件。
重要：建構子參數要增加必須在同一個建構子增加額外的參數，避免使用多載方式導致混淆。

結論是...
建構子注入模式是最通用的DI設計模式，主要作用在確保依賴需求可以被正確滿足。而如果你的依賴需求是非必要的，你可以在有適當的內建預設選項前提下，改用屬性注入模式。
*依賴需求很少會有非必要的類型，因此要將非必要的依賴需求設為必要，然後用『空值物件』設計模式*

| 優點                               | 缺點                                             |
| ---------------------------------- | ------------------------------------------------ |
| 保障依賴關係能夠被滿足             | 要是採用的框架有着『限制性建構』這個反模式存在， |
| 實作門檻不高                       | 那麼要實作建構子注入模式就會變得困難             |
| 可以明確地靜態定義出類別的依賴需求 |                                                  |

### 方法注入

當依賴對象可能會隨著每次呼叫的方法不同，又或者是依賴對象不變但每次的使用方都有可能變化時，就需要透過方法參數的形式來設定依賴關係。

像是Product物件 的 `public DiscountedProduct ApplyDiscountFor(IUserContext user)`
上面這個方法就會因為使用者資料不同，而導致不同的計算折扣方式，但是又需要依賴同一個物件


方法注入的適用情境有以下兩種：

對依賴對象而言：『當每次呼叫方法，注入的使用方都有可能不同時』
對使用方而言：『當每次方法被呼叫，注入的依賴對象都可能不同時』

>此部分的說明不甚理解，若是需要回想從 Page.130 回顧

| 優點                                                                                   | 缺點                                                            |
| -------------------------------------------------------------------------------------- | --------------------------------------------------------------- |
| 呼叫方可在每次操作時都提供不同設定資訊可以對不屬於組合根建立的資料導向物件進行依賴注入 | 適用的情境有限                                                  |
|                                                                                        | 變相導致類別或抽象界面的依賴關係，會分散定義在Public的API方法中 |                                                          |


#### 補充說明
一半應用程式開發情境下，建議將建構子注入模式預設爲DI架構採用的模式，反過來說如果是開發的時一個框架，那麼就便能大量適用方法注入模式，因爲方法注入模式就能讓框架具備將設定資訊傳遞給外掛沒做的能力。這也是爲什麼BCL會出現很多方法注入。


### 屬性注入

屬性注入的使用時機，應該只在該類別的依賴關係有適合的內建預設對象作爲前提時，但你卻還是希望能夠提供呼叫方一份彈性，可以對該類別提供不同的實作選擇。*請不要將屬性注入當作建構子過度注入問題的解方*。類別有過多依賴關係，上一種程式異樣，引入屬性注入模式並不會降低類別的複雜度。


| 優點     | 缺點                           |
| -------- | ------------------------------ |
| 簡單易懂 | 要實作的好並不容易             |
|          | 適用的情境種類有限             |
|          | *只適用於可重複利用的函式庫情境* |
|          | 會有造成時序耦合的疑慮         |




---

### 如何選擇注入模式
![[2012796.jpg]]





