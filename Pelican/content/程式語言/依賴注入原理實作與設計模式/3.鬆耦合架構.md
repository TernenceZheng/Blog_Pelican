---
title: 鬆耦合架構
date: 2022-04-13 13:55
modified: 2022-04-13 13:55
tags: 標籤
category: 後端程式
slug: 自定義URL標籤
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]


# 重新打造：流程是應該『由外而內』，先修改展示層 業務層 最後再 資料層


## 展示層修改：

#### View與POCO物件修改

```c
@model Ploeh.Samples.Commerce.Web.Models.FeaturedProductsViewModel

<h2>Featured Products</h2>
<div>
    @foreach (var product in this.Model.Products)
    {
        <div>@product.SummaryText</div>
    }
</div>


//下面是物件
public class FeaturedProductsViewModel
    {
        public FeaturedProductsViewModel(IEnumerable<ProductViewModel> products)
        {
            this.Products = products;
        }

        public IEnumerable<ProductViewModel> Products { get; }
    }
    
public class ProductViewModel
    {
        private static readonly CultureInfo PriceCulture = new CultureInfo("en-US");

        public ProductViewModel(DiscountedProduct product)
        {
            this.Name = product.Name;
            this.UnitPrice = product.UnitPrice;
        }

        public string Name { get; }
        public decimal UnitPrice { get; }
        public string SummaryText => string.Format(PriceCulture, "{0} ({1:C})", this.Name, this.UnitPrice);
    }
```

把物件的Product，轉換成FeaturedProductsViewModel與 ProductViewModel

重要：
這種改良就是把MVC的功能發揮，把原始的型別轉換為『單純的舊式資料物件』（POCO），與其他外來框架無涉依賴關係的單純實體物件。
從DI的架構觀點，不論是FeaturedProductsViewModel與 ProductViewModel 這類的POCO或DTO之類的視圖模型，都不是關注的焦點，因為這些視圖模型不會有攔截替換或是模擬的行為或程式邏輯，只是單純的放資料的物件，不會增加程式緊耦合的風險。

#### 在HomeController 的修改：

```c
    public class HomeController : Controller
    {
        private readonly IProductService productService;

        public HomeController(IProductService productService)
        {
            if (productService == null) throw new ArgumentNullException(nameof(productService));

            this.productService = productService;
        }

        public ViewResult Index()
        {
            IEnumerable<DiscountedProduct> featuredProducts =
                this.productService.GetFeaturedProducts();

            var vm = new FeaturedProductsViewModel(
                from product in featuredProducts
                select new ProductViewModel(product));

            return this.View(vm);
        }
    }
```


建構子用IProductService介面來注入的依賴對象
使用this.productService.GetFeaturedProducts(); 回傳一個DiscountedProduct依賴對象
featuredProducts這個東西就是資料層來的(*其實也是POCO資料類別，只是是DB來的*)，透過實際資料層物件來注入POCO物件，而不是什麼字串或是數字到View來呈現。

---

### 什麼是『組合根』

可以組合應用程式中使用的類別。
將需要實體物件的建立作業，全部集中化到一個地方，而這個負責處理作業的區塊就是『組合根』，通常是應用程式的啟動點，在NetCore就是Main方法中。

---


## 業務層的修改：

```c
public interface IProductService
    {
        IEnumerable<DiscountedProduct> GetFeaturedProducts();
    }
```

IProductService 這個介面就是業務層的核心，扮演了將 展示層與資料層介接起來的角色，也就是把應用程式中每個模組黏合起來的強力膠


```c
public interface IProductRepository
    {
        IEnumerable<Product> GetFeaturedProducts();
    }
```

IProductRepository 與上面IProductService 不同

IProductRepository是通往資料層的介面，返回的Product是 『資料實體』，資料實體代表的就是一個不僅僅存在於記憶體中的資料物件。

---
### 什麼是『資料實體』
*所有.NET中的物件在記憶體都會有一個代表其存在的記憶體位址，但是資料實體的識別不是這種離開程式流程或方法便會消滅或變動的東西。
通常在資料庫中資料表的主鍵值作為資料實體的存在識別，即時電腦重啟，這些鍵值也不會變動。因此之所以業務模型物件 Product 是一種資料實體，就是因為其資料是與程式流程生命週期無關*

---


```c

    public class Product
    {
        public Guid Id { get; set; }
        public string Description { get; set; }

        // ---- Start code Listing 3.8 ----
        public string Name { get; set; }
        public decimal UnitPrice { get; set; }
        public bool IsFeatured { get; set; }

        public DiscountedProduct ApplyDiscountFor(IUserContext user)
        {
            bool preferred = user.IsInRole(Role.PreferredCustomer);

            decimal discount = preferred ? .95m : 1.00m;

            return new DiscountedProduct(name: this.Name, unitPrice: this.UnitPrice * discount);
        }
        // ---- End code Listing 3.8 ----
    }
```

像是實體類別的這種有個方法ApplyDiscountFor 就有一個介面介入攔截使用者的資訊，就需要有介面去做依賴轉換。


```c
    public class ProductService : IProductService
    {
        private readonly IProductRepository repository;
        private readonly IUserContext userContext;

        public ProductService(
            IProductRepository repository,
            IUserContext userContext)
        {
            if (repository == null)
                throw new ArgumentNullException("repository");
            if (userContext == null)
                throw new ArgumentNullException("userContext");

            this.repository = repository;
            this.userContext = userContext;
        }

        public IEnumerable<DiscountedProduct> GetFeaturedProducts()
        {
            return
                from product in this.repository
                    .GetFeaturedProducts()
                select product.ApplyDiscountFor(this.userContext);
        }
    }
```


上面的分析步驟：首先有兩個東西透過建構子注入
```c
public ProductService(
            IProductRepository repository,
            IUserContext userContext)
```


藉由this.repository與this.userContext 變數所代表的依賴關係，獲取 商品清單，再依序加上折扣資訊，其中加上折扣資訊是透過方法注入(由this.userContext提供)
```c++
public IEnumerable<DiscountedProduct> GetFeaturedProducts()
        {
            return
                from product in this.repository
                    .GetFeaturedProducts()
                select product.ApplyDiscountFor(this.userContext);
        }
```


 #### *高階模組不應該依賴於低階模組，兩者都應該依賴抽象*（[[依賴注入系列]]）

ProductService 屬於高層的業務層

IProductRepository介面的實作實體類別=> SqlProductRepository 這個就是屬於低層的資料層



至於DI架構與依賴反轉原則之間的關聯：

>簡言之就是依賴反轉說明了我們想要實現的內容，而DI架構則是說明了我們該如何去實現這些內容。
>在這份範例中的鬆耦合架構，指明了抽象介面應該屬於介面使用方所在的模組。前面『屬於』的意思是*抽象介面的定義是掌握在作為使用方的模組手中，而且也是定義在那份模組當中，而不是由實作的這份介面的模組來負責*。由下圖來說明關聯即可瞭解清楚

![[DI概念圖.jpg]]


## 資料層的修改：


透過Entity Framework核心來實作IProductRepository，其中 重點是Entity Framework的核心有個『無關於定型框架』原則的資料實體
```c
    public class SqlProductRepository : IProductRepository
    {
        private readonly CommerceContext context;

        public SqlProductRepository(CommerceContext context)
        {
            if (context == null) throw new ArgumentNullException("context");

            this.context = context;
        }

        public IEnumerable<Product> GetFeaturedProducts()
        {
            return
                from product in this.context.Products
                where product.IsFeatured
                select product;
        }
    }
```


其中CommerceContext實作讀取連線設定，用
```C
    public class CommerceContext : DbContext
    {
        private readonly string connectionString;

        public CommerceContext(string connectionString)
        {
            if (connectionString == null) throw new ArgumentNullException(nameof(connectionString));
            if (string.IsNullOrWhiteSpace(connectionString))
                throw new ArgumentException("Value should not be empty.", nameof(connectionString));

            this.connectionString = connectionString;
        }

        public DbSet<Product> Products { get; set; }
        public DbSet<ExchangeRate> ExchangeRates { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(this.connectionString);
        }
    }
```

另外書上有提起另外一個重點，IUserContext 說明參考[[轉接器模式]]


## 分析新的依賴關係圖

虛線箭頭：使用
實線箭頭：實作

![[2006566.jpg]]

