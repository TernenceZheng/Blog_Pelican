---
title: 9.介入攔截
date: 2022-05-19 17:58
modified: 2022-05-19 17:58
tags: 標籤
category: 後端程式
slug: 自定義URL標籤
summary: 預覽標題
image: /images/default_preview_image.jpg
status: draft
---

[TOC]

學習重點：

+ 在兩物件之間的呼叫介入攔截
+ 何謂裝飾者設計模式
+ 利用裝飾者模式實作橫切關切點

## 關於攔截

所謂『攔截』指的是一種可以介入兩個協作元件之間的呼叫行為，以此強化或改變依賴對象的行為，但又不需要修改兩個協作元件本身內容的能力。攔截機制與實作，其實就是裝飾者設計模式的實作

裝飾者模式跟單純地在類別中持有依賴對象物件的差別在於：裝飾元件以及套在內層的被裝飾元件，都實作著同樣的抽象介面。
這種機制能讓組合器在不用更動任何使用方的情況下，就在原本的元件與裝飾元件之間隨意替換。這個要被套在內層的物件，通常是透過裝飾元件的建構子，以抽象介面型別參數注入進去的，因此被套在其中的，其實是以介面的名義，而非特定 實際的實體類別名義。

---

## 何謂裝飾者設計模式

在ECPay.Payment專案的信用卡功能的裝飾者模式，比書中的範例程式：Greeter 範例，還要多增加一個工廠方法，所以才能達成不用一層包一層，而是可以隨時使用SetProcess來設定

```c#
///這個是裝飾工廠
public class DecorateFactory
{
	IDecorateBase _original;

	public DecorateFactory(IDecorateBase original)
	{
		_original = original;
	}

	public DecorateFactory SetProcess(DecorateBase process)
	{
		process.SetDecorated(_original);
		_original = process;
		return this;
	}

	public IDecorateBase GetProcess()
	{
		return _original;
	}
}
```

```c#
///這個才是裝飾元件
public abstract class DecorateBase : IDecorateBase
    {
        /// <summary>
        /// 儲存被裝飾的物件
        /// </summary>
        protected IDecorateBase _process;

        public abstract object SetData<TObject, SObject>(TObject tObject, SObject paymentInfo, out object dynamicClass);

        public virtual void SetDecorated(IDecorateBase process)
        {
            _process = process;
        }
    }
```



## 利用裝飾者模式實作橫切關切點

直接使用範例來瞭解裝飾者模式：


### 以攔截實作斷路器設計模式

![[斷路器模式.jpg]]

裝飾元件
```c#
public class CircuitBreakerProductRepositoryDecorator : IProductRepository
{
	private readonly ICircuitBreaker breaker;
	private readonly IProductRepository decoratee;

	public CircuitBreakerProductRepositoryDecorator(
		ICircuitBreaker breaker, //斷路器機制
		IProductRepository decoratee)
	{
		this.breaker = breaker;
		this.decoratee = decoratee;
	}

	public static T Execute<T>(this ICircuitBreaker breaker, Func<T> action)
	{
		breaker.Guard(); //裝飾元件這裡就放一個斷路檢查機制，讓實作的依賴物件去定義

		try
		{
			T result = action();
			breaker.Succeed();

			return result;
		}
		catch (Exception ex)
		{
			breaker.Trip(ex);
			throw;
		}
	}
}
```

在應用程式組合作業中使用方式：
```c#
public App()
{
 this.InitializeComponent();
 this.Suspending += this.OnSuspending;

 this.navigationService = this;
 this.productRepository = 
	new CircuitBreakerProductRepositoryDecorator(
		new CircuitBreaker(TimeSpan.FromMinutes(1)), //CircuitBreaker就是斷路機制實作物件
		new FakeProductRepository());
}
```

實作功能的物件：
```c#
public class CircuitBreaker : ICircuitBreaker
{
	public CircuitBreaker(TimeSpan timeout)
	{
		this.State = new ClosedCircuitState(timeout);
	}

	public ICircuitState State { get; private set; }

	public void Guard()
	{
		this.State = this.State.NextState();
		this.State.Guard();
		this.State = this.State.NextState();
	}
}
```

其他機制也是類似一樣的方式去複製就大同小異，但是在這類情境中，如果需要把這份橫切關切點套用到一種抽象介面上，就可不是單純複製，就要談論導入到『剖面導向程式設計』。